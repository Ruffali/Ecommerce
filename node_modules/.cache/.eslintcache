[{"C:\\Users\\LENOVO\\OneDrive\\Desktop\\commerce_app\\src\\index.js":"1","C:\\Users\\LENOVO\\OneDrive\\Desktop\\commerce_app\\src\\App.js":"2","C:\\Users\\LENOVO\\OneDrive\\Desktop\\commerce_app\\src\\reportWebVitals.js":"3","C:\\Users\\LENOVO\\OneDrive\\Desktop\\commerce_app\\src\\hooks.js":"4","C:\\Users\\LENOVO\\OneDrive\\Desktop\\commerce_app\\src\\regex.js":"5","C:\\Users\\LENOVO\\OneDrive\\Desktop\\commerce_app\\src\\components\\styled.js":"6","C:\\Users\\LENOVO\\OneDrive\\Desktop\\commerce_app\\src\\pages\\Login\\Login.js":"7","C:\\Users\\LENOVO\\OneDrive\\Desktop\\commerce_app\\src\\containers\\LoginRight\\LoginRight.js":"8","C:\\Users\\LENOVO\\OneDrive\\Desktop\\commerce_app\\src\\containers\\LoginLeft\\LoginLeft.js":"9"},{"size":561,"mtime":1627827456626,"results":"10","hashOfConfig":"11"},{"size":165,"mtime":1627827396733,"results":"12","hashOfConfig":"11"},{"size":375,"mtime":1627821641190,"results":"13","hashOfConfig":"11"},{"size":3976,"mtime":1627821641185,"results":"14","hashOfConfig":"11"},{"size":268,"mtime":1627821641189,"results":"15","hashOfConfig":"11"},{"size":2079,"mtime":1627837901949,"results":"16","hashOfConfig":"11"},{"size":522,"mtime":1627831446383,"results":"17","hashOfConfig":"11"},{"size":3795,"mtime":1627838151710,"results":"18","hashOfConfig":"11"},{"size":1568,"mtime":1627833259270,"results":"19","hashOfConfig":"11"},{"filePath":"20","messages":"21","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},"180opag",{"filePath":"23","messages":"24","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"25","messages":"26","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"27","messages":"28","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"29","usedDeprecatedRules":"30"},{"filePath":"31","messages":"32","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"33","messages":"34","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"35","messages":"36","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"37","messages":"38","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"39","messages":"40","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},"C:\\Users\\LENOVO\\OneDrive\\Desktop\\commerce_app\\src\\index.js",[],["41","42"],"C:\\Users\\LENOVO\\OneDrive\\Desktop\\commerce_app\\src\\App.js",[],"C:\\Users\\LENOVO\\OneDrive\\Desktop\\commerce_app\\src\\reportWebVitals.js",[],"C:\\Users\\LENOVO\\OneDrive\\Desktop\\commerce_app\\src\\hooks.js",["43"],"import React, { useRef, useEffect, useState } from \"react\";\r\nexport function usePrevious(value) {\r\n  // The ref object is a generic container whose current property is mutable ...\r\n  // ... and can hold any value, similar to an instance property on a class\r\n  const ref = useRef();\r\n  // Store current value in ref\r\n  useEffect(() => {\r\n    ref.current = value;\r\n  }, [value]); // Only re-run if value changes\r\n  // Return previous value (happens before update in useEffect above)\r\n  return ref.current;\r\n}\r\n\r\nexport function useMemoCompare(next, compare) {\r\n  // Ref for storing previous value\r\n  const previousRef = useRef();\r\n  const previous = previousRef.current;\r\n  // Pass previous and next value to compare function\r\n  // to determine whether to consider them equal.\r\n  const isEqual = compare(previous, next);\r\n  // If not equal update previousRef to next value.\r\n  // We only update if not equal so that this hook continues to return\r\n  // the same old value if compare keeps returning true.\r\n  useEffect(() => {\r\n    if (!isEqual) {\r\n      previousRef.current = next;\r\n    }\r\n  }, [next, isEqual, compare]);\r\n  // Finally, if equal then return the previous value\r\n  return isEqual ? previous : next;\r\n}\r\n\r\nexport function useDebouncedCallback(callback, delay, options = {}) {\r\n  const maxWait = options.maxWait;\r\n  const maxWaitHandler = React.useRef(null);\r\n  const maxWaitArgs = React.useRef([]);\r\n\r\n  const leading = options.leading;\r\n  const trailing = options.trailing === undefined ? true : options.trailing;\r\n  const leadingCall = React.useRef(false);\r\n\r\n  const functionTimeoutHandler = React.useRef(null);\r\n  const isComponentUnmounted = React.useRef(false);\r\n\r\n  const debouncedFunction = React.useRef(callback);\r\n  debouncedFunction.current = callback;\r\n\r\n  const cancelDebouncedCallback = React.useCallback(() => {\r\n    clearTimeout(functionTimeoutHandler.current);\r\n    clearTimeout(maxWaitHandler.current);\r\n    maxWaitHandler.current = null;\r\n    maxWaitArgs.current = [];\r\n    functionTimeoutHandler.current = null;\r\n    leadingCall.current = false;\r\n  }, []);\r\n\r\n  React.useEffect(\r\n    () => () => {\r\n      // we use flag, as we allow to call callPending outside the hook\r\n      isComponentUnmounted.current = true;\r\n    },\r\n    []\r\n  );\r\n\r\n  const debouncedCallback = React.useCallback(\r\n    (...args) => {\r\n      maxWaitArgs.current = args;\r\n      clearTimeout(functionTimeoutHandler.current);\r\n      if (leadingCall.current) {\r\n        leadingCall.current = false;\r\n      }\r\n      if (!functionTimeoutHandler.current && leading && !leadingCall.current) {\r\n        debouncedFunction.current(...args);\r\n        leadingCall.current = true;\r\n      }\r\n\r\n      functionTimeoutHandler.current = setTimeout(() => {\r\n        let shouldCallFunction = true;\r\n        if (leading && leadingCall.current) {\r\n          shouldCallFunction = false;\r\n        }\r\n        cancelDebouncedCallback();\r\n\r\n        if (!isComponentUnmounted.current && trailing && shouldCallFunction) {\r\n          debouncedFunction.current(...args);\r\n        }\r\n      }, delay);\r\n\r\n      if (maxWait && !maxWaitHandler.current && trailing) {\r\n        maxWaitHandler.current = setTimeout(() => {\r\n          const _args = maxWaitArgs.current;\r\n          cancelDebouncedCallback();\r\n\r\n          if (!isComponentUnmounted.current) {\r\n            debouncedFunction.current.apply(null, _args);\r\n          }\r\n        }, maxWait);\r\n      }\r\n    },\r\n    [maxWait, delay, cancelDebouncedCallback, leading, trailing]\r\n  );\r\n\r\n  const callPending = React.useCallback(() => {\r\n    // Call pending callback only if we have anything in our queue\r\n    if (!functionTimeoutHandler.current) {\r\n      return;\r\n    }\r\n\r\n    debouncedFunction.current.apply(null, maxWaitArgs.current);\r\n    cancelDebouncedCallback();\r\n  }, [cancelDebouncedCallback]);\r\n\r\n  // At the moment, we use 3 args array so that we save backward compatibility\r\n  return [debouncedCallback, cancelDebouncedCallback, callPending];\r\n}\r\n",["44","45"],"C:\\Users\\LENOVO\\OneDrive\\Desktop\\commerce_app\\src\\regex.js",[],"C:\\Users\\LENOVO\\OneDrive\\Desktop\\commerce_app\\src\\components\\styled.js",[],"C:\\Users\\LENOVO\\OneDrive\\Desktop\\commerce_app\\src\\pages\\Login\\Login.js",[],"C:\\Users\\LENOVO\\OneDrive\\Desktop\\commerce_app\\src\\containers\\LoginRight\\LoginRight.js",[],"C:\\Users\\LENOVO\\OneDrive\\Desktop\\commerce_app\\src\\containers\\LoginLeft\\LoginLeft.js",[],{"ruleId":"46","replacedBy":"47"},{"ruleId":"48","replacedBy":"49"},{"ruleId":"50","severity":1,"message":"51","line":1,"column":36,"nodeType":"52","messageId":"53","endLine":1,"endColumn":44},{"ruleId":"46","replacedBy":"54"},{"ruleId":"48","replacedBy":"55"},"no-native-reassign",["56"],"no-negated-in-lhs",["57"],"no-unused-vars","'useState' is defined but never used.","Identifier","unusedVar",["56"],["57"],"no-global-assign","no-unsafe-negation"]