{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$();\n\nimport React, { useRef, useEffect, useState } from \"react\";\nexport function usePrevious(value) {\n  _s();\n\n  // The ref object is a generic container whose current property is mutable ...\n  // ... and can hold any value, similar to an instance property on a class\n  const ref = useRef(); // Store current value in ref\n\n  useEffect(() => {\n    ref.current = value;\n  }, [value]); // Only re-run if value changes\n  // Return previous value (happens before update in useEffect above)\n\n  return ref.current;\n}\n\n_s(usePrevious, \"8uVE59eA/r6b92xF80p7sH8rXLk=\");\n\nexport function useMemoCompare(next, compare) {\n  _s2();\n\n  // Ref for storing previous value\n  const previousRef = useRef();\n  const previous = previousRef.current; // Pass previous and next value to compare function\n  // to determine whether to consider them equal.\n\n  const isEqual = compare(previous, next); // If not equal update previousRef to next value.\n  // We only update if not equal so that this hook continues to return\n  // the same old value if compare keeps returning true.\n\n  useEffect(() => {\n    if (!isEqual) {\n      previousRef.current = next;\n    }\n  }, [next, isEqual, compare]); // Finally, if equal then return the previous value\n\n  return isEqual ? previous : next;\n}\n\n_s2(useMemoCompare, \"ud0eqeERstH8p4Lk8KApOUImOU4=\");\n\nexport function useDebouncedCallback(callback, delay, options = {}) {\n  _s3();\n\n  const maxWait = options.maxWait;\n  const maxWaitHandler = React.useRef(null);\n  const maxWaitArgs = React.useRef([]);\n  const leading = options.leading;\n  const trailing = options.trailing === undefined ? true : options.trailing;\n  const leadingCall = React.useRef(false);\n  const functionTimeoutHandler = React.useRef(null);\n  const isComponentUnmounted = React.useRef(false);\n  const debouncedFunction = React.useRef(callback);\n  debouncedFunction.current = callback;\n  const cancelDebouncedCallback = React.useCallback(() => {\n    clearTimeout(functionTimeoutHandler.current);\n    clearTimeout(maxWaitHandler.current);\n    maxWaitHandler.current = null;\n    maxWaitArgs.current = [];\n    functionTimeoutHandler.current = null;\n    leadingCall.current = false;\n  }, []);\n  React.useEffect(() => () => {\n    // we use flag, as we allow to call callPending outside the hook\n    isComponentUnmounted.current = true;\n  }, []);\n  const debouncedCallback = React.useCallback((...args) => {\n    maxWaitArgs.current = args;\n    clearTimeout(functionTimeoutHandler.current);\n\n    if (leadingCall.current) {\n      leadingCall.current = false;\n    }\n\n    if (!functionTimeoutHandler.current && leading && !leadingCall.current) {\n      debouncedFunction.current(...args);\n      leadingCall.current = true;\n    }\n\n    functionTimeoutHandler.current = setTimeout(() => {\n      let shouldCallFunction = true;\n\n      if (leading && leadingCall.current) {\n        shouldCallFunction = false;\n      }\n\n      cancelDebouncedCallback();\n\n      if (!isComponentUnmounted.current && trailing && shouldCallFunction) {\n        debouncedFunction.current(...args);\n      }\n    }, delay);\n\n    if (maxWait && !maxWaitHandler.current && trailing) {\n      maxWaitHandler.current = setTimeout(() => {\n        const _args = maxWaitArgs.current;\n        cancelDebouncedCallback();\n\n        if (!isComponentUnmounted.current) {\n          debouncedFunction.current.apply(null, _args);\n        }\n      }, maxWait);\n    }\n  }, [maxWait, delay, cancelDebouncedCallback, leading, trailing]);\n  const callPending = React.useCallback(() => {\n    // Call pending callback only if we have anything in our queue\n    if (!functionTimeoutHandler.current) {\n      return;\n    }\n\n    debouncedFunction.current.apply(null, maxWaitArgs.current);\n    cancelDebouncedCallback();\n  }, [cancelDebouncedCallback]); // At the moment, we use 3 args array so that we save backward compatibility\n\n  return [debouncedCallback, cancelDebouncedCallback, callPending];\n}\n\n_s3(useDebouncedCallback, \"nLczWVf7dDmUFMixDFxdwmhY4rE=\");","map":{"version":3,"sources":["C:/Users/LENOVO/OneDrive/Desktop/commerce_app/src/hooks.js"],"names":["React","useRef","useEffect","useState","usePrevious","value","ref","current","useMemoCompare","next","compare","previousRef","previous","isEqual","useDebouncedCallback","callback","delay","options","maxWait","maxWaitHandler","maxWaitArgs","leading","trailing","undefined","leadingCall","functionTimeoutHandler","isComponentUnmounted","debouncedFunction","cancelDebouncedCallback","useCallback","clearTimeout","debouncedCallback","args","setTimeout","shouldCallFunction","_args","apply","callPending"],"mappings":"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","sourcesContent":["import React, { useRef, useEffect, useState } from \"react\";\r\nexport function usePrevious(value) {\r\n  // The ref object is a generic container whose current property is mutable ...\r\n  // ... and can hold any value, similar to an instance property on a class\r\n  const ref = useRef();\r\n  // Store current value in ref\r\n  useEffect(() => {\r\n    ref.current = value;\r\n  }, [value]); // Only re-run if value changes\r\n  // Return previous value (happens before update in useEffect above)\r\n  return ref.current;\r\n}\r\n\r\nexport function useMemoCompare(next, compare) {\r\n  // Ref for storing previous value\r\n  const previousRef = useRef();\r\n  const previous = previousRef.current;\r\n  // Pass previous and next value to compare function\r\n  // to determine whether to consider them equal.\r\n  const isEqual = compare(previous, next);\r\n  // If not equal update previousRef to next value.\r\n  // We only update if not equal so that this hook continues to return\r\n  // the same old value if compare keeps returning true.\r\n  useEffect(() => {\r\n    if (!isEqual) {\r\n      previousRef.current = next;\r\n    }\r\n  }, [next, isEqual, compare]);\r\n  // Finally, if equal then return the previous value\r\n  return isEqual ? previous : next;\r\n}\r\n\r\nexport function useDebouncedCallback(callback, delay, options = {}) {\r\n  const maxWait = options.maxWait;\r\n  const maxWaitHandler = React.useRef(null);\r\n  const maxWaitArgs = React.useRef([]);\r\n\r\n  const leading = options.leading;\r\n  const trailing = options.trailing === undefined ? true : options.trailing;\r\n  const leadingCall = React.useRef(false);\r\n\r\n  const functionTimeoutHandler = React.useRef(null);\r\n  const isComponentUnmounted = React.useRef(false);\r\n\r\n  const debouncedFunction = React.useRef(callback);\r\n  debouncedFunction.current = callback;\r\n\r\n  const cancelDebouncedCallback = React.useCallback(() => {\r\n    clearTimeout(functionTimeoutHandler.current);\r\n    clearTimeout(maxWaitHandler.current);\r\n    maxWaitHandler.current = null;\r\n    maxWaitArgs.current = [];\r\n    functionTimeoutHandler.current = null;\r\n    leadingCall.current = false;\r\n  }, []);\r\n\r\n  React.useEffect(\r\n    () => () => {\r\n      // we use flag, as we allow to call callPending outside the hook\r\n      isComponentUnmounted.current = true;\r\n    },\r\n    []\r\n  );\r\n\r\n  const debouncedCallback = React.useCallback(\r\n    (...args) => {\r\n      maxWaitArgs.current = args;\r\n      clearTimeout(functionTimeoutHandler.current);\r\n      if (leadingCall.current) {\r\n        leadingCall.current = false;\r\n      }\r\n      if (!functionTimeoutHandler.current && leading && !leadingCall.current) {\r\n        debouncedFunction.current(...args);\r\n        leadingCall.current = true;\r\n      }\r\n\r\n      functionTimeoutHandler.current = setTimeout(() => {\r\n        let shouldCallFunction = true;\r\n        if (leading && leadingCall.current) {\r\n          shouldCallFunction = false;\r\n        }\r\n        cancelDebouncedCallback();\r\n\r\n        if (!isComponentUnmounted.current && trailing && shouldCallFunction) {\r\n          debouncedFunction.current(...args);\r\n        }\r\n      }, delay);\r\n\r\n      if (maxWait && !maxWaitHandler.current && trailing) {\r\n        maxWaitHandler.current = setTimeout(() => {\r\n          const _args = maxWaitArgs.current;\r\n          cancelDebouncedCallback();\r\n\r\n          if (!isComponentUnmounted.current) {\r\n            debouncedFunction.current.apply(null, _args);\r\n          }\r\n        }, maxWait);\r\n      }\r\n    },\r\n    [maxWait, delay, cancelDebouncedCallback, leading, trailing]\r\n  );\r\n\r\n  const callPending = React.useCallback(() => {\r\n    // Call pending callback only if we have anything in our queue\r\n    if (!functionTimeoutHandler.current) {\r\n      return;\r\n    }\r\n\r\n    debouncedFunction.current.apply(null, maxWaitArgs.current);\r\n    cancelDebouncedCallback();\r\n  }, [cancelDebouncedCallback]);\r\n\r\n  // At the moment, we use 3 args array so that we save backward compatibility\r\n  return [debouncedCallback, cancelDebouncedCallback, callPending];\r\n}\r\n"]},"metadata":{},"sourceType":"module"}